{% extends '_base.html' %}

{% block title %}Niamoto - Parcelle {{ plot.locality }}{% endblock %}
{% block extra_head %}
<script src="{{ depth }}js/plot_list.js"></script>

    <style>
        #plot-list li {
            list-style: none;
        }

        .plot-link {
            display: block;
            padding: 10px;
            border-radius: 5px;
            text-decoration: none;
        }

        .plot-link:hover {
            background-color: #f0f0f0;
        }

        .plot-link.active {
            background-color: #3498db;
            color: #fff;
        }

        #plotMap {
            position: relative;
            height: 400px;
        }

        .chart-container {
            position: relative;
            height: 400px; /* Fix the height */
            width: 100%; /* Ensure full width */
            max-width: 600px; /* Set a max-width to prevent it from being too wide */
            margin: 0 auto; /* Center the chart container */
          }
    </style>
{% endblock %}

{% block sidebar %}
<aside class="w-1/4 p-4 mt-28">
    <h2 class="font-semibold text-lg mb-4">List of Plots</h2>
    <ul id="plot-list" class="list-disc pl-5">
        <!-- The list of plots will be generated by JavaScript -->
    </ul>
</aside>
{% endblock %}
{% block content %}
<div class="rounded overflow-hidden shadow-lg mb-2 mt-28">
    <div class="px-6 py-4">
        <div class="font-bold text-4xl mb-2">{{ plot.locality }}</div>
    </div>
</div>

<div class="flex flex-wrap -mx-2">
    {% macro render_geography_field(field_key) %}
    <div class="w-full px-2 mb-4">
        <div class="rounded overflow-hidden shadow-lg p-4 bg-white">
            <div class="px-6 pt-4 pb-2">
                <div id="plotMap" style="height: 400px; position: relative;">
                    <div class="loader-container" id="mapLoader">
                        <div class="loader"></div>
                    </div>
                    <!-- The Leaflet map will be loaded here -->
                </div>
            </div>
        </div>
    </div>
    {% endmacro %}

    {% macro render_chart(transformation, field_key) %}
    {% if transformation.chart_options is defined %}
        <h2 class="font-bold text-xl mb-2">{{ transformation.chart_options.title }}</h2>
    {% endif %}
    {% if transformation.chart_type == 'text' %}
        <div class="w-full">
            <p id="{{ field_key }}Text"></p>
        </div>
    {% elif transformation.chart_type == 'pie' %}
        <canvas id="{{ field_key }}PieChart"></canvas>
    {% elif transformation.chart_type == 'gauge' %}
        <div class="gauge" id="{{ field_key }}{{ transformation.name if transformation.name is not none else '' }}Gauge"></div>
    {% elif transformation.chart_type == 'bar' %}
        <canvas class="chart-container" id="{{ field_key }}{{ transformation.name if transformation.name is not none else '' }}BarChart"></canvas>
    {% endif %}
    {% endmacro %}

    {% macro render_field(field_key, field) %}
        {% if field.bins and field.bins.values is defined %}
            <div class="w-1/2 px-2 mb-4">
                <div class="rounded overflow-hidden shadow-lg p-4 bg-white">
                    <h2 class="font-bold text-xl mb-2">{{ field.bins.chart_options.title }}</h2>
                    <canvas id="{{ field.source_field }}BinChart"></canvas>
                </div>
            </div>
        {% endif %}
        {% for transformation in field.transformations %}
            {% if transformation.chart_options is defined %}
            <div class="w-1/2 px-2 mb-4">
                <div class="rounded overflow-hidden shadow-lg p-4 bg-white">
                    {{ render_chart(transformation, field_key) }}
                </div>
            </div>
            {% endif %}
        {% endfor %}
    {% endmacro %}

    {% for field_key, field in mapping.fields.items() %}
        {% if field.field_type == 'GEOGRAPHY' %}
            {{ render_geography_field(field_key) }}
        {% else %}
            {{ render_field(field_key, field) }}
        {% endif %}
    {% endfor %}
</div>
{% endblock %}
{% block extra_scripts %}
<script>
    var plot = {{ plot | tojson | safe }};
    var mapping = {{ mapping | tojson | safe }};

    document.addEventListener('DOMContentLoaded', function () {
        loadPlotCharts(plot, mapping);
        loadPlotList(); // Chargement de la liste des plots
        setTimeout(initPlotMap, 0.5);
    });

    function loadPlotCharts(plot, mapping) {
        var frequencies = plot.frequencies;

        function generateColors(count, defaultColor) {
            if (defaultColor) {
                return Array(count).fill(defaultColor);
            }

            // Function to convert HSL to RGB
            function hslToRgb(h, s, l) {
                let r, g, b;

                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            // Function to convert RGB to Hex
            function rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            // Generate harmonious colors
            return Array.from({ length: count }, (_, i) => {
                // Use golden ratio to spread hues evenly
                const hue = (i * 0.618033988749895) % 1;

                // Vary saturation slightly
                const saturation = 0.5 + (i % 3) * 0.1;

                // Vary lightness to create contrast
                const lightness = 0.4 + (i % 2) * 0.2;

                const [r, g, b] = hslToRgb(hue, saturation, lightness);
                return rgbToHex(r, g, b);
            });
        }

        Object.entries(mapping.fields).forEach(function([field_key, field]) {
            if (field.field_type !== 'GEOGRAPHY') {
                // Chart for bins
                if (field.bins && field.bins.values && field.bins.values.length > 0 && frequencies && frequencies[field.source_field]) {
                    var labels, values;

                    // If labels and values are specified in the config, use them
                    if (field.bins.labels && field.bins.values) {
                        labels = field.bins.labels;
                        values = field.bins.values.map(value => frequencies[field_key][value] || 0);
                    } else {
                        // Create an array of objects with label and value
                        var dataArray = Object.entries(frequencies[field_key]).map(([label, value]) => ({label, value}));

                        // Sort the data array based on the numeric value of the label
                        dataArray.sort((a, b) => parseFloat(a.label) - parseFloat(b.label));

                        // Extract sorted labels and values
                        labels = dataArray.map(item => item.label);
                        values = dataArray.map(item => item.value);
                    }

                    // Reverse the order if indexAxis is 'y'
                    if (field.bins.chart_options.indexAxis === 'y') {
                        labels.reverse();
                        values.reverse();
                    }

                    var binData = {
                        labels: labels,
                        datasets: [{
                            label: field.label,
                            data: values,
                            backgroundColor: field.bins.chart_options.color
                        }]
                    };

                    var binConfig = {
                        type: field.bins.chart_type,
                        data: binData,
                        options: Object.assign({}, field.bins.chart_options, {
                            scales: {
                                x: {
                                    stacked: field.bins.chart_options.stacked || false
                                },
                                y: {
                                    stacked: field.bins.chart_options.stacked || false
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            const value = context.raw;
                                            return `${value}%`;
                                        }
                                    }
                                },
                                datalabels: {
                                    display: true,
                                    align: 'center',
                                    color: 'black',
                                    formatter: function (value) {
                                        return value + '%';
                                    }
                                }
                            }
                        })
                    };

                    var binCtx = document.getElementById(field_key + 'BinChart').getContext('2d');
                    new Chart(binCtx, binConfig);
                }

                // Charts for transformations
                field.transformations.forEach(function(transformation) {
                    var transformationName = transformation.name ? transformation.name : '';
                    var valueKey = transformation.name ? field_key + '_' + transformationName : field_key;
                    if (transformation.chart_type === 'text') {
                        var textElement = document.getElementById(field_key + 'Text');
                        if (textElement) {
                            textElement.textContent = plot[field_key];
                        }
                    } else if (transformation.chart_type === 'pie') {
                        var pieData = {
                            labels: ['True', 'False'],
                            datasets: [{
                                data: [
                                    plot[field_key + '_true'] || 0,
                                    plot[field_key + '_false'] || 0
                                ],
                                backgroundColor: ['#FF6384', '#36A2EB']
                            }]
                        };

                        var pieConfig = {
                            type: 'pie',
                            data: pieData,
                            options: {
                                title: {
                                    display: true,
                                    text: transformation.chart_options.title
                                }
                            }
                        };

                        var pieCtx = document.getElementById(field_key + 'PieChart');
                        if (pieCtx) {
                            pieCtx = pieCtx.getContext('2d');
                            new Chart(pieCtx, pieConfig);
                        }
                    } else if (transformation.chart_type === 'gauge') {
                        var gaugeOptions = {
                            id: field_key + transformationName + 'Gauge',
                            value: parseFloat(plot[valueKey]),
                            min: 0,
                            max: transformation.chart_options.max,
                            title: transformation.chart_options.title,
                            label: transformation.chart_options.label
                        };

                        createGauge(gaugeOptions);
                    } else if (transformation.chart_type === 'bar') {
                    var sortedData = Object.entries(plot[field_key+'_'+ transformation.name] || {})
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, transformation.count || 10);

                    var defaultColor = transformation.chart_options.defaultColor;
                    var colors = generateColors(sortedData.length, defaultColor);

                    var barData = {
                        labels: sortedData.map(item => item[0]),
                        datasets: [{
                            label: field.label,
                            data: sortedData.map(item => item[1]),
                            backgroundColor: colors,
                            borderColor: colors,
                            borderWidth: 1
                        }]
                    };

                    var barConfig = {
                        type: 'bar',
                        data: barData,
                        options: {
                            indexAxis: 'y',
                            responsive: false,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                },
                                title: {
                                    display: true,
                                    text: transformation.chart_options.title || 'Main Sub-taxa',
                                    font: {
                                        size: 16,
                                        weight: 'bold'
                                    },
                                    padding: {
                                        top: 10,
                                        bottom: 30
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Count',
                                        font: {
                                            weight: 'bold'
                                        }
                                    },
                                    ticks: {
                                        font: {
                                            weight: 'bold'
                                        }
                                    }
                                },
                                y: {
                                    ticks: {
                                        font: {
                                            weight: 'bold'
                                        }
                                    }
                                }
                            }
                        }
                    };

                    var fieldKey = field_key + transformation.name;
                    var barCtxElement = document.getElementById(fieldKey + 'BarChart');
                    if (barCtxElement) {
                        barCtxElement.style.height = '400px';  // Adjust height as needed
                        var barCtx = barCtxElement.getContext('2d');
                        new Chart(barCtx, barConfig);
                    }
                }
                });
            }
        });
    }

    function createGauge(options) {
        new JustGage({
            id: options.id,
            value: options.value || 0,
            min: options.min || 0,
            max: options.max,
            title: options.title,
            label: options.label,
            pointer: true,
            pointerOptions: {
                toplength: 10,
                bottomlength: 10,
                bottomwidth: 2,
                color: '#8e8e93',
                stroke: '#ffffff',
                stroke_width: 3,
                stroke_linecap: 'round'
            },
            gaugeWidthScale: 0.6,
            counter: true,
            donut: true,
            relativeGaugeSize: true,
            donutStartAngle: 270,
            hideInnerShadow: true,
            customSectors: [{
                color: "#ff0000",
                lo: 0,
                hi: options.max * 0.33
            }, {
                color: "#ffff00",
                lo: options.max * 0.33,
                hi: options.max * 0.66
            }, {
                color: "#00ff00",
                lo: options.max * 0.66,
                hi: options.max
            }],
            humanFriendly: true,
            formatNumber: true,
            textRenderer: function (val) {
                return parseFloat(val).toFixed(2); // Ensure value is displayed with 2 decimal places
            }
        });
    }

    function initPlotMap() {
        var geometry = plot.geometry;

        const satellite = L.tileLayer.wms("https://carto10.gouv.nc/arcgis/services/fond_imagerie/MapServer/WMSServer", {
            layers: '0',
            format: 'image/png',
            transparent: true,
            attribution: "<a href='http://www.geoportal.gouv.nc/'>Géorep</a> <i> - Gouvernement de la Nouvelle-Calédonie</i>"
        });
        const carte = L.tileLayer.wms('https://carto.gouv.nc/arcgis/services/fond_cartographie/MapServer/WMSServer', {
            layers: '0',
            format: 'image/png',
            transparent: true,
            attribution: "<a href='http://www.geoportal.gouv.nc/'>Géorep</a> <i> - Gouvernement de la Nouvelle-Calédonie</i>"
        });
        const map = L.map('plotMap', {
            layers: [carte, satellite],
            scrollWheelZoom: false
        });
        map.attributionControl.setPrefix(false); // Remove the "Powered by Leaflet" prefix
        map.attributionControl.addAttribution("<a href='http://www.geoportal.gouv.nc/'>Géorep</a> <i> - Gouvernement de la Nouvelle-Calédonie</i>");

        const baseMaps = {
            "Carte": carte,
            "Satellite": satellite,
        };

        L.control.layers(baseMaps).addTo(map);

        map.on('load', function () {
            document.getElementById('mapLoader').style.display = 'none';
        });

        if (geometry) {
            const geoJsonLayer = L.geoJSON(geometry, {
                style: function() {
                    return {
                        color: '#228b22', // Border color
                        weight: 2,       // Border width
                        fillColor: '#228b22cc', // Fill color with opacity
                        fillOpacity: 0.8 // Fill opacity
                    };
                }
            }).addTo(map);
            map.fitBounds(geoJsonLayer.getBounds());
            var currentZoom = map.getZoom();
            map.setZoom(currentZoom - 3);
        } else {
            console.warn("No geographic coordinates found.");
            // Set default view if no geometry is found
            map.setView([-21.291237, 165.516418], 8);
        }
    }

    function loadPlotList() {
        var plotListElement = document.getElementById("plot-list");
        plotList.forEach(function(plotItem) {
            var li = document.createElement("li");
            var a = document.createElement("a");
            a.href = "../plot/" + plotItem.id + ".html";
            a.textContent = plotItem.name;
            a.className = "plot-link" + (plotItem.id === plot.id ? " active" : "");
            li.appendChild(a);
            plotListElement.appendChild(li);
        });
    }

    // Function to get a color based on the index
    function getColor(index) {
        var colors = [
            {background: 'rgba(54, 162, 235, 0.6)', border: 'rgba(54, 162, 235, 1)'},
            {background: 'rgba(75, 192, 192, 0.6)', border: 'rgba(75, 192, 192, 1)'},
            {background: 'rgba(255, 99, 132, 0.6)', border: 'rgba(255, 99, 132, 1)'}
            // Add more colors if necessary
        ];
        return colors[index % colors.length]; // Repeat colors if more keys than defined colors
    }
</script>
{% endblock %}