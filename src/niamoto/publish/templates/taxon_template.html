{% extends '_base.html' %}
{% import '_widgets.html' as widgets %}

{% block title %}Niamoto - {{ taxon.full_name }}{% endblock %}

{% block extra_head %}
    <script src="{{ depth }}js/taxonomy_tree.js"></script>

    <style>
        /* Sidebar styles */
        #taxonomy-tree-container {
            height: 100vh;
            overflow-y: auto;
            padding-top: 1rem;
        }

        #taxonomy-tree {
            transition: all 0.3s ease-in-out;
        }

        @media (max-width: 1024px) {
            #taxonomy-tree:not(.hidden) {
                animation: slideDown 0.3s ease-in-out;
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .search-container {
            position: relative;
            width: 100%;
            margin-bottom: 1rem;
        }

        #taxonSearch {
            width: 100%;
            padding: 0.5rem 0.5rem 0.5rem 2.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 23%;
            color: #666;
            pointer-events: none;
        }

        #taxonomy-tree ul {
            list-style-type: none;
            padding-left: 20px;
        }

        #taxonomy-tree li {
            margin: 5px 0;
        }

        #taxonomy-tree .toggle {
            cursor: pointer;
            margin-right: 5px;
        }

        #taxonomy-tree a {
            text-decoration: none;
            color: #333;
        }

        #taxonomy-tree a:hover {
            text-decoration: underline;
        }

        #taxonomy-tree .current-taxon {
            font-weight: bold;
            color: #007bff;
        }

        /* Map styles */
        .map-container {
            position: relative;
            width: 100%;
            height: 400px;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Chart styles */
        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 1rem;
        }

        /* Widget styles */
        .widget-container {
            @apply bg-white rounded-lg shadow-lg overflow-hidden mb-4 md:mb-0;
        }

        .widget-header {
            @apply bg-gray-600 text-white p-3;
        }

        .widget-content {
            @apply p-4;
            min-height: 300px;
        }

        .tooltip-content {
            position: absolute;
            top: 110%;
            left: 50%;
            transform: translateX(-100%);
            background-color: #ffffff;
            color: #333333;
            padding: 0.5rem;
            border-radius: 0.25rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            white-space: normal;
            width: 20rem;
            z-index: 9999;
            display: none;
        }

        .group:hover .tooltip-content {
            display: block;
        }

        @media (max-width: 768px) {
            #taxonomy-tree-container {
                height: auto;
                border-right: none;
                border-bottom: 1px solid #dee2e6;
            }

            .widget-content {
                min-height: 250px;
            }

            .map-container {
                height: 300px;
            }
        }

        .loading-indicator {
            padding: 8px 10px;
            background: white;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0,0,0,0.1);
            border-top-color: #007bff;
            border-radius: 50%;
            margin-right: 8px;
            animation: spin 1s linear infinite;
        }

        #imageModal {
            background: rgba(255, 255, 255, 0); /* Fond semi-transparent noir autour */
        }

        #imageModal > div {
            background-color: transparent; /* Rend le fond du conteneur transparent */
            box-shadow: none; /* Supprime l'ombre si nécessaire */
        }

        #imageModal img {
            border-radius: 8px; /* Coins arrondis pour l'image directement */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Ombre légère autour de l'image */
        }


@keyframes spin {
    to {transform: rotate(360deg);}
}
    </style>

    <script>
        const taxonId = {{ taxon.id }};
    </script>
{% endblock %}

{% block sidebar %}
    <div class="w-full mt-16 lg:w-1/4 lg:min-h-screen bg-white shadow-md overflow-y-auto">
        <button id="sidebar-toggle"
                class="lg:hidden w-full flex items-center justify-between p-4 text-gray-600 hover:bg-gray-50">
            <span>Taxonomie</span>
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
        </button>

        <div id="taxonomy-tree-container" class="hidden lg:block p-4">
            <label for="taxonSearch"></label>
            <div class="search-container">
                <input type="text" id="taxonSearch" class="w-full mb-4 pl-10" aria-label="Search taxon">
                <i class="fas fa-search search-icon" aria-hidden="true"></i>
            </div>
            <div id="taxonomy-tree">
                <!-- The taxonomic tree will be loaded here -->
            </div>
        </div>
    </div>
{% endblock %}

{% block content %}
    <div class="flex-1 p-4">
        <div class="container mx-auto px-4 md:px-6 py-4 md:py-8">
            {# Full width widgets #}
            <div class="mt-16">
                {% for widget_key, widget in mapping.widgets.items() if widget.layout == 'full_width' %}
                    {{ widgets.render_widget_content(widget, widget_key, stats) }}
                {% endfor %}
            </div>

            {# Grid layout widgets #}
            <div class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-2 2xl:grid-cols-3 gap-4 mt-4">
                {% for widget_key, widget in mapping.widgets.items() if widget.layout != 'full_width' %}
                    {{ widgets.render_widget_content(widget, widget_key, stats) }}
                {% endfor %}
            </div>
        </div>
    </div>
{% endblock %}

{% block extra_scripts %}
    <script>
        // =====================================
        // Constants & Initial Setup
        // =====================================
        const taxon = {{ taxon | tojson | safe }};
        const mapping = {{ mapping | tojson | safe }};

        // =====================================
        // Core Initialization
        // =====================================
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize sidebar
            initializeSidebar();

            // Initialize tree
            const treeContainer = document.getElementById('taxonomy-tree');
            if (treeContainer) {
                createTree(treeContainer, taxonomyData);
            }

            // Initialize all widgets
            initializeWidgets(mapping.widgets, taxon);
        });

        // =====================================
        // Sidebar Management
        // =====================================
        function initializeSidebar() {
            const sidebarToggle = document.getElementById('sidebar-toggle');
            const taxonomyTree = document.getElementById('taxonomy-tree-container');

            if (sidebarToggle && taxonomyTree) {
                sidebarToggle.addEventListener('click', function () {
                    taxonomyTree.classList.toggle('hidden');
                    this.classList.toggle('menu-open');

                    const svg = this.querySelector('svg');
                    if (this.classList.contains('menu-open')) {
                        svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />';
                    } else {
                        svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />';
                    }
                });

                // Close menu on outside click for mobile
                document.addEventListener('click', function (e) {
                    if (!sidebarToggle.contains(e.target) &&
                        !taxonomyTree.contains(e.target) &&
                        !taxonomyTree.classList.contains('hidden') &&
                        window.innerWidth < 1024) {
                        taxonomyTree.classList.add('hidden');
                        sidebarToggle.classList.remove('menu-open');
                        const svg = sidebarToggle.querySelector('svg');
                        svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />';
                    }
                });
            }
        }

        // =====================================
        // Widget Management
        // =====================================
        function initializeWidgets(widgets, stats) {
            // Mapping des types vers leurs fonctions d'initialisation
            const initializerMap = {
                'bar_chart': initChart,
                'line_chart': initChart,
                'pie_chart': initChart,
                'doughnut_chart': initChart,
                'gauge': initChart,
                'map_panel': initMap
            };

            Object.entries(widgets)
                .filter(([_, config]) => config.type in initializerMap)  // Ignore unsupported types
                .forEach(([widgetKey, config]) => {
                    // Automatically generate the widget ID if not specified
                    const suffix = config.type.includes('chart') ? 'Chart' :
                        config.type === 'gauge' ? 'Gauge' : 'Map';
                    const widgetId = config.id || `${widgetKey}${suffix}`;

                    // For maps, we directly pass stats
                    if (config.type === 'map_panel') {
                        initializerMap[config.type](widgetId, stats, config);
                        return;
                    }

                    // For other widgets, we check the source in stats
                    const data = _.get(stats, config.source);
                    if (!data) return;  // Skip if no data

                    // Initialize the widget with the appropriate function
                    initializerMap[config.type](widgetId, data, config);
                });
        }


        // =====================================
        // Tree Management
        // =====================================
        function getBaseUrl() {
            const pathArray = window.location.pathname.split('/');
            pathArray.pop();
            return pathArray.join('/') + '/';
        }

        function openCurrentNode($ul, currentId) {
                const $currentLink = $ul.find(`a[data-id='${currentId}']`);
                if ($currentLink.length > 0) {
                    // Open all parents as you already do
                    $currentLink.parents('ul').each(function () {
                        $(this).show();
                        $(this).siblings('span').text('▾');
                    });

                    // Wait a short moment to ensure the nodes are properly opened
                    setTimeout(() => {
                        // Scroll to the selected element
                        const container = document.getElementById('taxonomy-tree-container');
                        const element = $currentLink[0];

                        if (container && element) {
                            // Calculate the scroll position to center the element if possible
                            const elementRect = element.getBoundingClientRect();
                            const containerRect = container.getBoundingClientRect();
                            const offset = elementRect.top - containerRect.top - (containerRect.height / 2) + (elementRect.height / 2);

                            // Perform scrolling with smooth animation
                            container.scrollTo({
                                top: container.scrollTop + offset,
                                behavior: 'smooth'
                            });
                        }
                    }, 100); // A short delay to ensure the DOM is updated
                }
            }

        function createTree(container, taxonomyData) {
            const baseUrl = getBaseUrl();

            function createList(data) {
                const $ul = $('<ul></ul>');
                $.each(data, function (i, item) {
                    const $li = $('<li></li>');
                    const $a = $('<a></a>', {
                        'href': `${baseUrl}${item.id}.html`,
                        'text': item.name,
                        'data-id': item.id
                    });

                    if (item.id == taxonId) {
                        $a.css({
                            'font-weight': 'bold',
                        });
                    }

                    if (item.children && item.children.length > 0) {
                        const $span = $('<span>▸</span>').css({
                            'cursor': 'pointer',
                            'margin-right': '5px'
                        });

                        const $childUl = createList(item.children).hide();
                        $span.click(function (event) {
                            event.stopPropagation();
                            $childUl.toggle();
                            $(this).text($childUl.is(":visible") ? '▾' : '▸');
                        });

                        $li.append($span).append($a).append($childUl);
                    } else {
                        $li.append($a);
                    }
                    $ul.append($li);
                });
                return $ul;
            }

            const $tree = createList(taxonomyData);
            $(container).append($tree);
            openCurrentNode($tree, taxonId);
        }


        // =====================================
        // Map Management
        // =====================================
        function initMap(mapId, data, mapConfig) {
                const mapContainer = document.getElementById(mapId);
                if (!mapContainer) return;

                // Get map configuration from widget config or defaults
                const baseLayersConfig = (mapConfig.map_config && mapConfig.map_config.base_layers) ||
                (mapping.map_config && mapping.map_config.base_layers) ||
                []; // Fallback to empty array if no config

                // Default configurations
                const defaultZoom = (mapConfig.map_config && mapConfig.map_config.default_zoom) ||
                (mapping.map_config && mapping.map_config.default_zoom) || 7;
                const maxZoom = (mapConfig.map_config && mapConfig.map_config.max_zoom) ||
                (mapping.map_config && mapping.map_config.max_zoom) || 12;

                // Base layers with global defaults
                const baseLayers = {};

                // Always include global backups for reliability
                baseLayers["OpenStreetMap"] = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: maxZoom
                });

                baseLayers["ESRI Satellite"] = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: maxZoom
                });

                // Add configured layers
                let defaultLayer = baseLayers["ESRI Satellite"]; // Fallback default

                baseLayersConfig.forEach(layerConfig => {
                    // Create layer based on type (WMS or standard)
                    if (layerConfig.url_wms) {
                        // WMS layer
                        baseLayers[layerConfig.name] = L.tileLayer.wms(layerConfig.url_wms, {
                        layers: layerConfig.wms_layers || '0',
                        format: layerConfig.format || 'image/png',
                        transparent: true,
                        attribution: layerConfig.attribution || '',
                        maxZoom: maxZoom,
                        timeout: 5000
                        });
                    } else if (layerConfig.url) {
                        // Standard tile layer
                        baseLayers[layerConfig.name] = L.tileLayer(layerConfig.url, {
                        attribution: layerConfig.attribution || '',
                        maxZoom: maxZoom
                        });
                    }

                    // Set as default layer if specified
                    if (layerConfig.default && baseLayers[layerConfig.name]) {
                        defaultLayer = baseLayers[layerConfig.name];
                    }
                });

                // Create map with default layer
                const map = L.map(mapId, {
                    layers: [defaultLayer],
                    zoom: defaultZoom,
                    maxZoom: maxZoom,
                    scrollWheelZoom: false
                });

                // Add layer control
                L.control.layers(baseLayers).addTo(map);
                map.attributionControl.setPrefix(false);

                // Determine the data source based on mapConfig
                const dataSource = mapConfig.source;

                // Create a marker cluster group with custom options for better performance
                const markers = L.markerClusterGroup({
                    maxClusterRadius: 30, // Smaller radius makes more, smaller clusters
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    zoomToBoundsOnClick: true,
                    disableClusteringAtZoom: 12, // Disable clustering at max zoom
                    chunkedLoading: true, // Load markers in chunks to avoid freezing
                    chunkProgress: updateProgressBar // Optional progress callback
                });

                // Process and add markers
                setTimeout(() => {
                    processMarkers(data, dataSource, mapConfig, markers, map);
                }, 100); // Small delay to allow UI to render first

                // Add empty cluster layer to map immediately (will be populated)
                map.addLayer(markers);

                // Add a loading indicator
                const loadingIndicator = L.control({ position: 'topright' });
                loadingIndicator.onAdd = function (map) {
                    this._div = L.DomUtil.create('div', 'loading-indicator');
                    this._div.innerHTML = '<div class="spinner"></div> Loading points...';
                    return this._div;
                };
                loadingIndicator.addTo(map);

                function updateProgressBar(processed, total, elapsed) {
                    if (processed === total) {
                        // Hide loading indicator when complete
                        loadingIndicator.getContainer().style.display = 'none';
                    }
                }
            }

            // Separate function to process markers to avoid blocking the UI
            function processMarkers(data, dataSource, mapConfig, markers, map) {
                // Check if the data is in GeoJSON standard format
                if (data && data[dataSource] && data[dataSource].type === "FeatureCollection") {
                    const geoJsonData = data[dataSource];

                    if (geoJsonData.features && geoJsonData.features.length > 0) {
                        // Sample large datasets (optional)
                        let features = geoJsonData.features;
                        if (features.length > 2000) {
                            // Sample only first 2000 points to avoid browser freezing
                            features = features.slice(0, 2000);
                            console.warn(`Map showing only 2000 points out of ${geoJsonData.features.length}`);
                        }

                        // Process in batches to avoid freezing the UI
                        processBatch(features, 0, 100, markers, mapConfig, map);
                    }
                }
                // Keep compatibility with the old format
                else if (data && data[dataSource]) {
                    const coordinatesSource = mapConfig.layers[0].source;

                    if (data[dataSource][coordinatesSource]) {
                        // Sample large datasets (optional)
                        let points = data[dataSource][coordinatesSource];
                        if (points.length > 2000) {
                            points = points.slice(0, 2000);
                            console.warn(`Map showing only 2000 points out of ${data[dataSource][coordinatesSource].length}`);
                        }

                        // Process in batches to avoid freezing the UI
                        processLegacyBatch(points, 0, 100, markers, mapConfig, map);
                    }
                }
            }

            // Process a batch of GeoJSON features
            function processBatch(features, startIndex, batchSize, markers, mapConfig, map) {
                const endIndex = Math.min(startIndex + batchSize, features.length);
                const bounds = [];

                for (let i = startIndex; i < endIndex; i++) {
                    const feature = features[i];
                    if (feature.geometry && feature.geometry.type === "Point") {
                        const coords = feature.geometry.coordinates;
                        const latLng = [coords[1], coords[0]];

                        // Create circle marker instead of standard marker for better performance
                        const marker = L.circleMarker(latLng, {
                            ...mapConfig.layers[0].style,
                            radius: 5 // Smaller radius for better performance
                        });

                        // Add popup only on click to improve performance
                        if (feature.properties) {
                            marker.on('click', function () {
                                const popupContent = Object.entries(feature.properties)
                                    .map(([key, value]) => `${key}: ${value}`)
                                    .join('<br>');

                                marker.bindPopup(popupContent || "Occurrence").openPopup();
                            });
                        }

                        markers.addLayer(marker);
                        bounds.push(latLng);
                    }
                }

                // Process next batch or fit bounds
                if (endIndex < features.length) {
                    setTimeout(() => {
                        processBatch(features, endIndex, batchSize, markers, mapConfig, map);
                    }, 10); // Small timeout to allow UI to update
                } else {
                    // All features processed, fit bounds if needed
                    if (bounds.length > 0) {
                        map.fitBounds(L.latLngBounds(bounds), {
                            maxZoom: 12,
                            padding: [50, 50]
                        });
                    }
                }
            }

            // Process a batch of legacy format points
            function processLegacyBatch(points, startIndex, batchSize, markers, mapConfig, map) {
                const endIndex = Math.min(startIndex + batchSize, points.length);
                const bounds = [];

                for (let i = startIndex; i < endIndex; i++) {
                    const point = points[i];
                    const latLng = [point.coordinates[1], point.coordinates[0]];

                    const marker = L.circleMarker(latLng, {
                        ...mapConfig.layers[0].style,
                        radius: 5 // Smaller radius for better performance
                    });

                    // Add popup only on click
                    marker.on('click', function () {
                        marker.bindPopup(`Occurrences: ${point.count || 1}`).openPopup();
                    });

                    markers.addLayer(marker);
                    bounds.push(latLng);
                }

                // Process next batch or fit bounds
                if (endIndex < points.length) {
                    setTimeout(() => {
                        processLegacyBatch(points, endIndex, batchSize, markers, mapConfig, map);
                    }, 10);
                } else {
                    // All points processed, fit bounds if needed
                    if (bounds.length > 0) {
                        map.fitBounds(L.latLngBounds(bounds), {
                            maxZoom: 12,
                            padding: [50, 50]
                        });
                    }
                }
            }

        // =====================================
        // Chart Type Management & Data Processing
        // =====================================
        /**
         * Maps widget types to Chart.js chart types
         * @param {string} widgetType - Type from widget configuration
         * @returns {string} Corresponding Chart.js type
         */
        function getChartTypeFromWidgetType(widgetType) {
            const typeMapping = {
                'doughnut_chart': 'doughnut',
                'pie_chart': 'pie',
                'bar_chart': 'bar',
                'line_chart': 'line',
                'stacked_bar_chart': 'bar',
                'gauge': 'gauge'
            };
            return typeMapping[widgetType] || 'bar'; //
        }

        /**
         * Prepares data for chart rendering, including sorting and transformation
         * @param {Object} config - Widget configuration
         * @param {Object} data - Raw data for the chart
         * @returns {Object} Formatted data for Chart.js
         */
        function prepareChartData(config, data) {
            const datasets = [];
            let labels = [];

            if (!config.datasets || !Array.isArray(config.datasets)) {
                console.warn('No datasets configuration provided');
                return {labels: [], datasets: []};
            }

            // Get and sort data if needed
            let sortedData = data;
            let sortedIndices = null;
            if (config.sortBy) {
                const values = _.get(data, config.sortBy, []);
                sortedIndices = values.map((v, i) => i);
                sortedIndices.sort((a, b) => values[a] - values[b]);

                // Create new sorted data object
                sortedData = Object.keys(data).reduce((acc, key) => {
                    if (Array.isArray(data[key])) {
                        acc[key] = sortedIndices.map(i => data[key][i]);
                    } else {
                        acc[key] = data[key];
                    }
                    return acc;
                }, {});
            }

            // Get labels before dataset processing
            labels = config.labels_key ?
                _.get(sortedData, config.labels_key, []).map(v => v.toString()) :
                config.labels ? config.labels :
                    [];

            config.datasets.forEach((datasetConfig) => {
                const dataset = {
                    label: datasetConfig.label,
                    data: [],
                    backgroundColor: [],
                    borderColor: [],
                    borderWidth: datasetConfig.borderWidth ?? 1,
                    fill: datasetConfig.fill ?? false,
                    tension: datasetConfig.tension ?? 0,
                    stack: datasetConfig.stack,
                    pointRadius: datasetConfig.pointRadius ?? undefined,
                    pointHoverRadius: datasetConfig.pointHoverRadius ?? undefined,
                    pointHoverBackgroundColor: datasetConfig.pointHoverBackgroundColor ?? undefined,
                };

                // Process data
                dataset.data = processDataset(datasetConfig, sortedData, config.type);

                // Transform data if needed
                if (datasetConfig.transformData) {
                    dataset.data = dataset.data.map((value, index) =>
                        transformDataValue(value, datasetConfig.transformData, index, sortedData)
                    );
                }

                // Process colors after data is loaded
                processColors(dataset, datasetConfig, labels);

                datasets.push(dataset);
            });

            return {labels, datasets};
        }

        /**
         * Prepares chart options by merging defaults with configuration
         * Handles scales, plugins, and callbacks configuration
         * @param {Object} config - Widget configuration
         * @returns {Object} Complete Chart.js options
         */
        function prepareChartOptions(config) {
            // Default options restent les mêmes
            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            padding: 20,
                            usePointStyle: false,
                            boxWidth: 15,
                        },
                    },
                    title: {
                        display: false,
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                    },
                },
                scales: {},
            };

            // Merge custom options with defaults
            const options = _.merge({}, defaultOptions, config.options);

            // Handle scales configuration
            if (config.options && config.options.scales) {
                Object.keys(options.scales || {}).forEach(scaleKey => {
                    const scale = options.scales[scaleKey];
                    if (scale.ticks && scale.ticks.callback) {
                        const callbackName = scale.ticks.callback;
                        if (typeof window[callbackName] === 'function') {
                            scale.ticks.callback = window[callbackName];
                        }
                    }
                });
            }

            // Handle stacked charts
            if (config.type === 'stacked_bar_chart' || (config.options && config.options.stacked)) {
                if (options.scales.x) options.scales.x.stacked = true;
                if (options.scales.y) options.scales.y.stacked = true;
            }

            // Process plugin callbacks
            if (options.plugins) {
                for (const pluginKey in options.plugins) {
                    const plugin = options.plugins[pluginKey];
                    if (plugin.callbacks) {
                        for (const callbackKey in plugin.callbacks) {
                            const callbackName = plugin.callbacks[callbackKey];
                            if (typeof callbackName === 'string' && typeof window[callbackName] === 'function') {
                                plugin.callbacks[callbackKey] = window[callbackName];
                            }
                        }
                    }
                }
            }

            return options;
        }

        /**
         * Process dataset values according to chart type
         */
        function processDataset(datasetConfig, data, chartType) {
            let processedData = [];

            if (datasetConfig.data_keys && Array.isArray(datasetConfig.data_keys)) {
                processedData = datasetConfig.data_keys.map(key => {
                    const value = parseFloat(_.get(data, key, 0)) || 0;
                    return formatValue(value, chartType);
                });
            } else if (datasetConfig.data_key) {
                const values = _.get(data, datasetConfig.data_key, []);
                processedData = Array.isArray(values) ?
                    values.map(value => formatValue(parseFloat(value) || 0, chartType)) :
                    [formatValue(parseFloat(values) || 0, chartType)];
            } else if (datasetConfig.data) {
                processedData = Array.isArray(datasetConfig.data) ?
                    datasetConfig.data.map(value => formatValue(parseFloat(value) || 0, chartType)) :
                    [formatValue(parseFloat(datasetConfig.data) || 0, chartType)];
            }

            return processedData;
        }

        /**
         * Process colors for chart datasets
         */
        function processColors(dataset, datasetConfig, labels) {
            if (datasetConfig.generateColors) {
                // Génère autant de couleurs que de données
                dataset.backgroundColor = generateColors(dataset.data.length);
                dataset.borderColor = dataset.backgroundColor;
                return;
            }

            if (datasetConfig.color_mapping && labels) {
                dataset.backgroundColor = Array.isArray(dataset.data) ?
                    dataset.data.map((_, index) => {
                        const label = labels[index];
                        return datasetConfig.color_mapping[label] || '#000000';
                    }) :
                    datasetConfig.color_mapping[labels[0]] || '#000000';

                dataset.borderColor = datasetConfig.borderColor || dataset.backgroundColor;
            } else if (datasetConfig.backgroundColors) {
                dataset.backgroundColor = datasetConfig.backgroundColors;
                dataset.borderColor = datasetConfig.borderColor || datasetConfig.backgroundColors;
            } else if (datasetConfig.backgroundColor) {
                dataset.backgroundColor = datasetConfig.backgroundColor;
                dataset.borderColor = datasetConfig.borderColor || dataset.backgroundColor;
            } else {
                dataset.backgroundColor = '#000000';
                dataset.borderColor = '#000000';
            }
        }

        function generateColors(count, defaultColor) {
            if (defaultColor) {
                return Array(count).fill(defaultColor);
            }

            // Function to convert HSL to RGB
            function hslToRgb(h, s, l) {
                let r, g, b;

                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            // Function to convert RGB to Hex
            function rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            // Generate harmonious colors
            return Array.from({length: count}, (_, i) => {
                // Use golden ratio to spread hues evenly
                const hue = (i * 0.618033988749895) % 1;

                // Vary saturation slightly
                const saturation = 0.5 + (i % 3) * 0.1;

                // Vary lightness to create contrast
                const lightness = 0.4 + (i % 2) * 0.2;

                const [r, g, b] = hslToRgb(hue, saturation, lightness);
                return rgbToHex(r, g, b);
            });
        }

        /**
         * Initialize chart widgets including gauges
         * Handles both Chart.js charts and JustGage gauges
         */
        function initChart(widgetId, data, config) {
            const ctx = document.getElementById(widgetId);
            if (!ctx) return;

            const chartType = getChartTypeFromWidgetType(config.type);

            if (chartType === 'gauge') {
                const rawValue = _.get(data, config.value_key);

                if (rawValue === null || rawValue === undefined || isNaN(rawValue)) {
                    if (ctx) {
                        ctx.className = 'flex items-center justify-center h-64';
                        ctx.innerHTML = '<p class="text-gray-500 italic">Pas de données disponibles</p>';
                    }
                    return;
                }

                const value = parseFloat(rawValue.toFixed(1));

                const gaugeOptions = {
                    id: widgetId,
                    value: value,
                    min: config.options.min,
                    max: config.options.max,
                    label: config.options.units,
                    title: config.title,
                    gaugeColor: "#eee",
                    levelColors: config.options.sectors.map(s => s.color),
                    decimals: 1,
                    gaugeWidthScale: 0.6,
                    counter: true,
                    pointer: true,
                    pointerOptions: {
                        toplength: -15,
                        bottomlength: 10,
                        bottomwidth: 12,
                        color: '#8E8E93',
                        stroke: '#fff',
                        stroke_width: 3,
                        stroke_linecap: 'round'
                    },
                    // Default options that don't need to be in config
                    showMinMax: false,
                    donut: false,
                    relativeGaugeSize: true,
                    // Font colors that don't need to be in config
                    titleFontColor: "#333",
                    valueFontColor: "#333",
                    labelFontColor: "#666"
                };

                const gauge = new JustGage(gaugeOptions);

                // Add value text below
                const valueText = document.createElement('p');
                valueText.className = 'text-center mt-5 text-lg text-gray-700';
                ctx.parentNode.appendChild(valueText);

                return;
            }

            // Pour les autres types de graphiques...
            const chartData = prepareChartData(config, data);

            // Vérifier si les données sont vides
            let hasData = false;

            if (chartData && chartData.datasets) {
                // Vérifier si au moins un dataset contient des données
                hasData = chartData.datasets.some(dataset => {
                    // Vérifier si le dataset a des données et qu'elles ne sont pas toutes nulles/0
                    return dataset.data &&
                           dataset.data.length > 0 &&
                           dataset.data.some(value => value !== null && value !== undefined && value !== 0);
                });
            }

            // Si aucune donnée n'est disponible, afficher un message
            if (!hasData) {
                if (ctx) {
                    // Remplacer le canvas par un div avec le message
                    const container = ctx.parentNode;
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'flex items-center justify-center h-64';
                    messageDiv.innerHTML = '<p class="text-gray-500 italic">Pas de données disponibles</p>';
                    container.replaceChild(messageDiv, ctx);
                }
                return;
            }

            const chartOptions = prepareChartOptions(config);
            const plugins = [];

            if (config.customPlugin && typeof window[config.customPlugin] === 'object') {
                plugins.push(window[config.customPlugin]);
            }

            new Chart(ctx, {
                type: chartType,
                data: chartData,
                options: chartOptions,
                plugins: plugins,
            });
        }

        // =====================================
        // Value Formatters
        // =====================================
        // Various formatters for different data types
        window.formatLogValue = function (value) {
            return value.toString();
        };
        window.formatSurfaceValue = function (value) {
            if (value >= 1000000) {
                return (value / 1000000).toFixed(1) + 'M';
            }
            if (value >= 1000) {
                return (value / 1000).toFixed(0) + 'k';
            }
            return value;
        };
        window.formatPercentage = function (value) {
            return value.toFixed(0) + '%';
        };
        window.formatForestTypeTooltip = function (context) {
            return context.dataset.label + ': ' + context.raw.toFixed(1) + '%';
        };
        window.formatTooltipLabel = function (context) {
            return `${context.label}: ${context.parsed}%`;
        };
        window.formatForestTypeElevationTooltip = function (context) {
            const value = Math.round(context.raw);  // ou .toFixed(0) pour aucune décimale
            return context.dataset.label + ': ' + value + '%';
        };
        window.formatAbsoluteValue = function (value) {
            // Si c'est zéro, on l'affiche au centre
            if (value === 0) return '0';
            // Pour les autres valeurs, on affiche la valeur absolue
            return Math.abs(value).toString();
        };

        window.formatForestCoverTooltip = function (context) {
            const label = context.dataset.label;
            const value = Math.abs(context.raw).toFixed(1);
            return `${label}: ${value}%`;
        };

        function transformDataValue(value, transform, valueIndex, allData) {
            if (!transform) return value;

            switch (transform) {
                case 'negateValues':
                    return isNaN(value) ? 0 : -value;
                case 'toPercentage':
                    return isNaN(value) ? 0 : value * 100;
                case 'stackedPercentage':
                    const total = ['secondaire', 'mature', 'coeur'].reduce((sum, key) =>
                        sum + (allData[key] ? allData[key][valueIndex] : 0), 0);
                    return total === 0 ? 0 : (value / total * 100);
                default:
                    return value;
            }
        }

        function formatValue(value, chartType) {
            switch (chartType) {
                case 'doughnut_chart':
                case 'pie_chart':
                    return Number(value);
                default:
                    return value;
            }
        }

        // =====================================
        // Custom Plugins
        // =====================================
        /**
         * Custom plugin for drawing labels on doughnut charts
         */
        window.customLabels = {
            id: 'customLabels',
            afterDraw: function (chart) {
                const ctx = chart.ctx;
                ctx.save();
                ctx.font = '11px system-ui';
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';

                const datasets = chart.data.datasets;
                const meta = chart.getDatasetMeta(0);
                const centerX = meta.data[0].x;
                const centerY = meta.data[0].y;

                datasets.forEach((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    const percentage = dataset.data[0];
                    const element = meta.data[0];

                    const percentageAngle = -Math.PI + 0.2;
                    const radius = (element.innerRadius + element.outerRadius) / 2;
                    const x = centerX + Math.cos(percentageAngle) * radius;
                    const y = centerY + Math.sin(percentageAngle) * radius;

                    ctx.fillText(percentage.toFixed(1) + '%', x, y);

                    // Affichage du label
                    ctx.fillText(dataset.label, centerX, centerY + element.outerRadius - 10);
                });

                ctx.restore();
            }
        };

        /**
         * Custom plugin for drawing percentage labels on forest type charts
         */
        window.forestTypeLabelsPlugin = {
            id: 'text',
            afterDraw: function (chart) {
                const ctx = chart.ctx;
                chart.data.datasets.forEach(function (dataset, i) {
                    const meta = chart.getDatasetMeta(i);
                    meta.data.forEach(function (element, index) {
                        const value = dataset.data[index];
                        const position = element.getCenterPoint();

                        // Draw value
                        ctx.save();
                        ctx.fillStyle = '#000000';
                        ctx.font = '12px system-ui';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(value.toFixed(1) + '%', position.x, position.y);
                        ctx.restore();
                    });
                });
            }
        };

        /**
             * Custom plugin for drawing percentage labels on taxonomic distribution chart
             */
            window.percentagePlugin = {
                id: 'percentagePlugin',
                afterDraw: function (chart) {
                    const ctx = chart.ctx;

                    // Vérifier si c'est un graphique circulaire ou en barres
                    if (chart.config.type === 'doughnut' || chart.config.type === 'pie') {
                        // Code original pour les graphiques circulaires
                        chart.data.datasets.forEach(function (dataset, i) {
                            const meta = chart.getDatasetMeta(i);
                            meta.data.forEach(function (element, index) {
                                // Ne pas afficher si la valeur est trop petite
                                const value = dataset.data[index];
                                if (value < 2) return; // Skip small values

                                // Calcul de la position pour l'étiquette
                                const angle = element.startAngle + (element.endAngle - element.startAngle) / 2;
                                const radius = (element.innerRadius + element.outerRadius) / 2;
                                const x = element.x + Math.cos(angle) * radius * 0.7;
                                const y = element.y + Math.sin(angle) * radius * 0.7;

                                // Dessiner le pourcentage
                                ctx.save();
                                ctx.fillStyle = '#FFFFFF';
                                ctx.font = 'bold 14px system-ui';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';

                                // Ajouter un contour noir pour améliorer la lisibilité
                                ctx.strokeStyle = '#000000';
                                ctx.lineWidth = 3;
                                ctx.lineJoin = 'round';
                                ctx.strokeText(value.toFixed(1) + '%', x, y);
                                ctx.fillText(value.toFixed(1) + '%', x, y);

                                ctx.restore();
                            });
                        });
                    } else if (chart.config.type === 'bar') {
                        // Nouveau code pour les graphiques en barres
                        chart.data.datasets.forEach(function (dataset, i) {
                            const meta = chart.getDatasetMeta(i);
                            meta.data.forEach(function (element, index) {
                                const value = dataset.data[index];
                                if (value < 2) return; // Skip small values

                                // Obtenir les dimensions et la position de la barre
                                const { x, y, width, height } = element.getProps(['x', 'y', 'width', 'height']);

                                // Calculer le centre de la barre
                                let centerX, centerY;

                                // Vérifier si c'est un graphique horizontal ou vertical
                                if (chart.options.indexAxis === 'y') {
                                    // Graphique horizontal
                                    centerX = x + width / 2;
                                    centerY = y;
                                } else {
                                    // Graphique vertical
                                    centerX = x;
                                    centerY = y + height / 2;
                                }

                                // Dessiner le pourcentage
                                ctx.save();
                                ctx.fillStyle = '#FFFFFF';
                                ctx.font = 'bold 14px system-ui';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';

                                ctx.strokeStyle = '#000000';
                                ctx.lineWidth = 3;
                                ctx.lineJoin = 'round';
                                ctx.strokeText(value.toFixed(1) + '%', centerX, centerY);
                                ctx.fillText(value.toFixed(1) + '%', centerX, centerY);
                                ctx.restore();
                            });
                        });
                    }
                }
            };
    </script>
{% endblock %}
